---
title: "どのようにTypeScriptを使うのか"
published: "2021-10-23T21:00+09:00"
tags:
  - TypeScript
---

現在、TypeScriptの重要性は、フロントエンド開発を中心としてますます増すばかりであります。それだけに、**TypeScriptをどのように使うべきか**という問題については多様な意見が見られます。

これまで筆者はTypeScriptの使い方について意見を発信してきましたが、この記事でも改めて考えをお伝えします。特に、次のような意見に対しての反対意見を述べます。

- 厳しいコンパイラオプションは型パズル愛好者のためのものであり、普通の人は細かいことを気にせず緩い設定でよい。
- 熟練のJavaScript使いにはTypeScriptは必要ない。

# 例え話

最近はTypeScriptを補助輪に例えたりするのが流行っていますので、この記事でも例え話をしてみます。筆者の考えでは、TypeScriptというのは例えるならば**料理人が使う包丁**のようなものです。コンパイラオプションが色々あるのは、場面に応じて適した包丁が10本くらいある状況です。

この例えでいくと、上の2つの意見は次のように言い換えられるでしょう。

- 包丁を使い分けるのは料理マニアのやることであり、普通の料理人は出刃包丁1本でよい。
- 熟練の料理人はおもちゃの包丁で何でも作れる。

いかがでしょうか。こう書くと、あなたが賛成かどうか決めやすいかもしれません。おおよそ「プロは道具を選ばない」派と「プロは道具を使いこなす」派に分かれるのではないでしょうか。筆者は後者です。

この例え話を通じて最も伝えたいことは、**TypeScriptは道具である**ということです。JavaScriptプログラミングにおいて、ある目的（コードの安全性といったこと）を達成するために使われる道具、それがTypeScriptです。たまに、TypeScriptを枷だと思う人がいますが、そのような見方は目的意識を希薄化してしまうのであまりおすすめしません。以降は「TypeScriptは道具である」という考え方をベースに論を組み立てていきます。

# 各論 (1) コンパイラオプションをどうするか

TypeScriptを採用したとしても、コンパイラオプションをどうするかというのは意見が分かれるところです。筆者の意見は、**可能な限り厳しいオプションを使用せよ**です。もちろん、特殊な事情がある場合は別です（既存のJavaScriptコードをTypeScriptに移行する必要がある場合など）。

TypeSrciptを道具と考える見方では、**コンパイラオプションはあなたが目的に沿って主体的に決めなければいけません**。コンパイラオプションに興味を持たないということは、TypeScriptという道具をどのように使うのかということ（すなわち、あなたがTypeScriptを使う目的）に興味を持たないということであり、本末転倒です。

幸いにも、TypeScriptはコンパイラオプションの数こそ多いものの、難しく考える必要はありません。包丁とは違って、10通りの異なる選択肢を場合に応じて使い分ける必要は無いのです。大部分のオプションは、**より安全かどうか**というたった一つの軸で判断できます。コンパイラオプションを有効にするとより安全で、有効にしないと安全ではありません（すなわち、特定のケースで安全性が保証されなくなります）。

このことを「コンパイラオプションを有効にすればするほど縛りが厳しくなる」と表現できるかもしれません。そうなると、「自分は自由に書きたいしそんなに厳しくなくて良いかな……」と思ってしまいがちですが、それは踏みとどまってください。コンパイラオプションを無効にして設定を緩くして得られる自由とは、**危険なコードを書く自由**です。つまり、**安全性に関わるコンパイラオプションを無効にするということは、危険なコードを書くという目的があってはじめて正当化されることです**。

## TypeScriptを黙らせたいと思ったら

「そうは言ってもTypeScriptは頭が悪すぎて、俺が書いた完璧に安全なコードに文句を言ってくる。自由に書かせろ」といった反論は考えられます。実際、安全なコードなのにTypeScriptがうまく型推論できなくてコンパイルエラーが出てしまう場面はあります。

しかし、そういった場面で取るべき行動は、コンパイラオプションを無効化することではありません。そうではなく、`any`や`as`やユーザー定義型ガードといった危険な道具を使うことです。なぜなら、コンパイラオプションはプロジェクト全体に影響を与えるからです。コードをなるべく安全に保ちたいならば、危険な道具の影響範囲をあの手この手で最小限にとどめることが必要であり、そのためには`as`などのほうが適しています。

## 歴史的な事情

そもそも、TypeScriptに色々なコンパイラオプションが用意されている理由は、歴史的に見ればもっぱら**後方互換性のため**です。

TypeScriptは進化の過程で型チェック力を増し、その安全性を増してきました。よりチェックが厳しくなることは、TypeScriptを使用している既存のプロジェクトから見たら破壊的変更となります。以前はコンパイルエラーが出なかったコードに対して、TypeScriptのバージョンを上げるとコンパイルエラーが出てしまうからです。

小さめの破壊的変更は普通にリリースされますが、既存のコードへの影響が大きいと思われる大きな改善はコンパイラオプションの形でリリースされ、コンパイラオプションを有効にした人だけ新しい改善が適用されるという戦略がとられます。最近の例としては、TypeScript 4.4でリリースされた`useUnknownInCatchVariables`オプションが挙げられます。自分のコードが新しいチェックに耐えられない場合は、このオプションを無効化することでひとまずコンパイルエラーを消すことができます。もちろん、長期的にはオプションを有効化できるようにコードの改善を進めていくべきであることは言うまでもありません。

つまるところ、安全性に関わるコンパイラオプションが導入された動機は、**新しい安全性レベルに適合できない既存コードのコンパイルを通すため**であり、安全性レベルの選択肢を与えることは元々の意図ではありません。特に、新規のTypeScriptプロジェクトでは、その時点で利用可能な安全性オプションをわざわざ無効にする理由がありません。だからこそ、敢えて選択肢として解釈しても、上記のように「危険なコードを書く自由」といった魅力のない選択肢にしかならないのです。

## 関数引数の型を書きたくない

TypeScriptのコンパイラオプションについては上記のように説明しましたが、実際のところほとんどのコンパイラオプションについてはあまり議論になるのを見かけません。議論の的となる代表的なコンパイラオプションは`noImplicitAny`です。このオプションは、いくつかの危険なシチュエーションにおける挙動を指定するもので、オプションを有効にするとコンパイルエラーとなる場面でも、オプションを無効にすると`any`型が推論されてコンパイルエラーになりません。

`noImplicitAny`を無効化した場合に発生する大きな違いは、**関数引数の型を書かなくても良くなる**ことです。

```ts
// noImplicitAnyを無効にするとコンパイルエラーにならないコード
function mapToSign(arr) {
  return arr.map(x => x >= 0);
}

// noImplicitAny有効下ではこうする必要がある
function mapToSign(arr: readonly number[]) {
  return arr.map(x => x >= 0);
}
```

TypeScriptでは、型推論が働くためには関数引数の型を明示的に書く必要があります。これは推論力が足りないというよりは、TypeScriptがそのようなデザインを採用しているということです。関数型言語を中心に、引数の型を書かなくても関数の使われ方から推論してくれる言語もありますが、TypeScriptはそうではありません。おそらく、型チェック速度を遅くしないためというのが最も大きな理由でしょう。

このことが気に入らない人が、`noImplicitAny`の無効化（さらには、そもそもTypeScriptを使わないこと）を支持する傾向にあるというのが筆者の印象です。曰く、十分能力がある人なら引数の型をわざわざ書かなくても十分安全なコードにできるというのです。

これに対する反論としては、次の言葉を引用します。

> 生JavaScriptでも、たとえば「この変数には数値だけが入っているはずだ」みたいな意識が生じたらもうそこには型システムが存在していて、あとはその人の頭の中だけにある貧弱で曖昧な型システムを使うか、みんなが使ってて自動的に検証できるTypeScriptの型システムを使うか、という違いしかないです
>
> https://twitter.com/cubbit2/status/1430923767643992065

たとえ引数の型を書かなかったとしても、「引数として何が渡されるか」といったことは考慮する必要があります。上のコードでも、型が書いていないとはいえ引数`arr`に配列以外を渡してはいけません。そうするとコンパイルエラーは出ないもののランタイムエラーになってしまうからです。つまり、何らかの形で「`mapToSign`に配列以外を渡さないこと」をケアしてあげる必要があります。

もしあなたがこのようなランタイムエラーを避けたいのなら、それはコードの安全性を気にしているということです。TypeScriptでは、型を書かないということは、コードの安全性をあなたの責任において保証してあげる必要があるということを意味します。そのためにあなたが脳内で思考したことは、実質的にTypeScriptの型チェッカーが普段やっていることと同じです。

そして、ほとんど全ての場合において、型チェックによる安全性の保証というタスクはあなたの脳内型チェッカーよりもTypeScriptの方がうまくやってくれますから、TypeScriptに任せるべきです（残りのレアケースにおいては人間が責任を負う必要があり、`as`なり何なりを使うことでTypeScriptと協調しながらできるようになっています）。

型にあまり魅力を感じない人にとっては、`noImplicitAny`を無効にすることは「わざわざ型を書かなくて良くなる」という点で魅力的に見えるかもしれません。しかし、（バグをなるべく防ぎたいという前提がある限りは）実際には結局あなたの脳内型チェックが必要です。それはわざわざTypeScriptの仕事を減らして自分の仕事を増やす行為であり、素直に型を書くのに比べて100倍くらい大変なことなのです。

ただ、あなたの脳内での型チェックというのは、TypeScriptが無い時代にJavaScript使いがやってきたことであり、今でも静的型システムの無い言語を書く人がやり続けていることです。このような場合、当然ながら安全性の保証を担ってくれるプログラムは無く、人間の責任において安全性を担保する（＝ランタイムエラーを含むある種のバグたちを防ぐ）ことになります。これはTypeScriptが何もしてくれない状態、すなわち**TypeScriptが保証してくれる安全性がゼロ**の状態と解釈できます。

上記の説明から分かるように、`noImplicitAny`を無効にすると、「TypeScriptが何も保証してくれない」という状態に近づきます。このことから、`noImplicitAny`も他のコンパイラオプションと同様に、無効にするとTypeScriptによる安全性保証が低下するものであることが分かります。他のコンパイラオプションと同様に、後方互換性といった事情が無い限り、無効にする理由が無いのです。

ただし、少し前でも触れましたが、`noImplicitAny`を無効にすることは「JavaScriptのコードをTypeScriptに移行したい」という特定のシチュエーションにおいては有用です。これはまさにTypeScriptによる安全性の保証がゼロの状態から安全性を高めていかなければならない状況であり、途中のマイルストーンとして「`noImplicitAny`が無効ならコンパイルが通る」という目標を設定することは有用でしょう。

ただし、`noImplicitAny`が無効の状態をゴールとすることにはとても慎重にならなければいけません。TSへの移行といった特別な事情を抜きにして考えれば、この記事で述べたように、`noImplicitAny`を無効にするというのはTypeScriptが保証してくれる安全性を敢えて低下させるという能動的な選択に他なりません。そのようなことは、「かかる労力とのトレードオフ」といった外的な事情によってはじめて正当化されます。というのも、`noImplicitAny`が無効の状態から有効の状態に持っていくことは、非常に大きな労力がかかります（筆者の会社では筆者が属するチームが実際にこれを行ないましたが、1年以上かかりました）。そこまでして得られる安全性保証と、そのための労力を天秤にかけることで、「安全性を諦める」という選択が正当化されうるのです。逆に言えば、新規のプロジェクトを立ち上げる場合にはそのようなしがらみが無く、`noImplicitAny`の無効化を正当化することはとても困難です。

## 厳しいオプションは誰のためか

これまでに説明した通り、TypeScriptで安全性のためのコンパイラオプションを有効化すると、チェックが厳しくなります。「厳しい」と言われると、特にTypeScript初心者の方は、「初心者がいきなり厳しい設定にしなくても良いのではないか」と思うかもしれません。しかし、それは典型的な誤解です。むしろ、**初心者こそもっとも厳しい設定にすべき**です。

これまで述べてきたように、TypeScriptを使用するのは、型チェックにより安全性を保証するためです。では、なぜTypeScriptを使うのでしょうか。それはもちろん、バグを減らすためです。

厳しい設定を無効化するということは、TypeScriptによる安全性保証の精度を低下させるということです。つまり、端的に言えば（期待値的に）**バグが増える**ということです。もしバグを増やすことがあなたの目的ならば、設定を緩くしてそれで終わりでもよいでしょう。しかし、多くの職業プログラマがそうであるように、あなたの成果物にクオリティが求められるのであれば、バグが増えることは望ましいことではありません。

その場合、TypeScriptの力が低下した分を、人間が補ってあげる必要があります（上記でいう、人間の責任というやつです）。では、TypeScriptが最大限の力を発揮してくれるのと、TypeScriptがやってくれることの一部を人間が肩代わりしなければいけない場合とでは、どちらが初心者向けでしょうか。言うまでもなく、前者です。

したがって、**なるべくコンパイラオプションを厳しくするほうがむしろ初心者向けである**と言えます。

さらに言えば、熟練のエンジニアだろうと、コンパイラオプションを緩くする理由はありません。この記事でこれまでも述べているように、「人間の責任」が必要になったとしても、その手段はコンパイラオプションという大域的なものではなく、`as`などといった局所的な危険性を持つ手段が使われるからです。

以上のことから、冒頭で紹介した以下のような意見に筆者が否定的である理由がお分かりでしょう。

> 厳しいコンパイラオプションは型パズル愛好者のためのものであり、普通の人は細かいことを気にせず緩い設定でよい。

ちなみにさらに言えば、型パズル（ここでは高度・難解な型定義全般という意味で使っています）の愛好者はむしろ`any`と`as`のほうを好んで使うので、コンパイラオプションはやはり無関係です。コンパイラオプションはあくまでTypeScriptが保証してくれる安全性がどの程度かを決めるものであり、高度な型を書くかどうかには関係しないものです。

# 各論 (2) JSDocでよくない？

TypeScriptは、実はJSDocに対するサポートにも力を入れています。型註釈の構文が使用できない`.js`ファイルであっても、JSDocコメントを通じて型を書くことで、型チェックの恩恵を受けられるという機能です。

```js
/**
 * @param {readonly number[]} arr
 */
function mapToSign(arr) {
  return arr.map(x => x >= 0);
}
```

TypeScript不要論の変種として、型チェックの恩恵は受けつつ、TypeScriptに特有の構文を避けてJSDocで全てを書くべきであるという主張も最近見かけられます。これに対しても筆者の意見は否定的です。

## JSDocに寄せることのメリットとは

JSDocに寄せることのメリットは、トランスパイルが必要なくなることです。これが唯一のメリットと言っても過言ではなく、筆者は他のメリットが思いつきません。

そもそも、TypeScriptの文法はJavaScriptを型註釈のための構文で拡張したものです[^note_enum]が、これはJavaScriptではないため、ブラウザやNode.jsといった処理系でそのまま動かせません[^note_deno]。そのためJavaScriptへの変換作業が必要で、これがトランスパイルと呼ばれています。

[^note_enum]: `enum`といった例外があるのはご存知の通りですが、これは歴史的経緯の産物であるため本質ではなく、簡単のため省略しています。
[^note_deno]: Denoならそのまま動かせるよと思った読者の方がいるかもしれませんが、Denoも裏でトランスパイルしてからJavaScript処理系にかけているので本質的には同じことです。

トランスパイルが必要であることの問題点は、環境構築の手間がかかることです。トランスパイルをするためのツール（`tsc`など）をインストールしたり、それを自動で実行したりするための環境を整える必要があります。

以上がTypeScriptをJSDocで使うことのメリットとして知られているものですが、筆者はやはり懐疑的です。まず、特にフロントエンド全般はなかなか環境構築に手間がかかる分野であることは否めません。バンドラーなどを開発に取り入れるとビルドフローが複雑化します。しかし、**実はTypeScript単体では大した手間にならない**というのが筆者の考えです。最も単純なトランスパイル作業とは、`.ts`ファイルをトランスパイラに入力して`.js`ファイルを得ることです。そのための環境構築は、慣れている人ならば`tsconfig.json`のセットアップを含めても5分とかからないでしょう。設定ファイルも、JSONファイルひとつだけです。また、トランスパイルにかかる時間が気になる人もいるかもしれませんが、esbuildの登場によってその方面の問題もかなり解消されました。

開発環境の維持管理コストという観点もあるかもしれませんが、TypeScript使いならばそれくらい管理してくれと正直なところ思います。包丁の例えで言えば、自らの道具をメンテナンスすることも料理人に必要なスキルだということです。

node.jsが使えないのでトランスパイルができないといったエクストリームな環境（それでどうやって型チェックだけ可能なのかはさて置いて）では、JSDocで頑張る価値があるかもしれません。しかしそれは、そのようなエクストリームな環境だからそうするのであって、いつでもそうすべきということではありません。料理人がすごく狭い台所で料理を作れたとしても、レストランの厨房が狭い台所であるべきという話にはならないでしょう。

## JSDocのデメリット

あまり「メリット・デメリット」という二元的な分け方が好きではないのですが、JSDocのデメリットについても述べておきます。一言で言えば、**むやみに長くて面倒くさい**です。例えば、同じ意味の型註釈をTypeScriptの構文とJSDocの構文で書いてみます（JSDocは[TypeScript Documentation](https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#template)から引用）。

```ts
// JSDoc
/**
 * @template {string} K - K must be a string or string literal
 * @template {{ serious(): string }} Seriousalizable - must have a serious method
 * @param {K} key
 * @param {Seriousalizable} object
 */
function seriousalize(key, object) {
}

// TypeScript
function seriousalize<
  K extends string,
  Seriousalizable extends { serious(): string }
>(key: K, object: Seriousalizable) {
}
```

この面倒くささは、TypeScriptとは無関係に存在していたJSDocを無理やり流用しているというのがその理由のひとつでしょう。また、コメントとタグという形式に縛られている都合から、`@param`や`@template`といったタグを毎回書かなければいけない点など無駄が多く、さらに、TypeScriptの構文に比べて構造化が十分ではありません。

プログラムの読み書きしやすさのために構文の簡潔さが必要であるというのは、Rustなどの最近の流れを見ているとどうも正しいように思われます。JSDocによる書き方はその逆を強制します。よその言語はよその言語だと思われるかもしれませんが、JavaScriptでもES2015でのアロー関数の導入や`{ foo }`といったオブジェクトリテラルの省略形の導入など、書きやすさ・読みやすさのための処置が取られています。最近議論されているパイプライン演算子などもその類でしょう。

「コメントで書ける」というのは、プログラムとしての読み書きしやすさとしてはTypeScriptの構文よりも劣るものであり、トランスパイルが必要ないという点のみでTypeScriptの構文に張り合っているものだというのが筆者の意見です。

# まとめ

この記事では、「TypeScriptのコンパイラオプションはどのように決めるべきか」「TypeScriptは不要なのではないか」といった問いに対する筆者の考え方をご紹介しました。

コンパイラオプションについては、「よく分からないけど人々が言い争ってるもの」などと思っている方がいたとしたら、それはやめましょう。TypeScriptという道具をあなたがあなたの目的のために使う以上、コンパイラオプションはあなた自身があなたの目的にしたがって主体的に設定すべきものである、というのが筆者の考えです。その考え方に従うと、最も厳しい設定にする以外の選択肢を取る理由は極めて希薄なものとなるでしょう。

記事の後半では、TypeScript不要論の中でも最近話題になっていた「JSDocで良い」論について筆者の考えを紹介しました。